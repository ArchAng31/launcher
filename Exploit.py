#!/usr/bin/env python3

from socket import *

class Exploit():
    def __init__(self, ip, port, name="", debug=False):
        self.ip = ip
        self.port = port
        self.name = name
        self.debug = debug
        self.dprint("Launching Exploit")
        self.sock = self.connect_to_client()

    #this is a debug print. Set debug to True to see
    #set debug to false to turn off
    def dprint(self, text):
        if self.debug:
            print(self.name + ': ' + text)

    #basic connect to client
    def connect_to_client(self):
        # Create a TCP/IP socket
        sock = socket(AF_INET, SOCK_STREAM)
        # Connect the socket to the port where the server is listening
        server_address = (self.ip, self.port)
        self.dprint('Connecting to %s port %s.' % server_address)
        #sock.connect(server_address)
        #TODO: NEED TO ADD ERROR HANDLING HERE
        return sock

    #basic client_recv example
    def client_recv():
        data = sock.recv(1000)
        while data == "":
            data = sock.recv(1000)
        return data


#example basic exploit test inside this same class file
class ExploitTest(Exploit):
    def __init__(self, ip, port, name="", debug=False):
        super().__init__(ip, port, name, debug)

    def get_flag(self):
        #here is where you would write the code to connect to
        #and exploit the service. Finish it by returning the flag
        return "CTF{THISISMYFLAG}"

    def send_chaff(self):
        #This is where you would write a fake exploit that does not really
        #work, but looks real enough to cause them to waste time looking for
        #the real exploit.
        pass
