#!/usr/bin/env python3

from socket import *
import sys

class Exploit():
    def __init__(self, ip, port, name="", debug=False, debug_chaff=False):
        self.ip = ip
        self.port = port
        self.name = "{:30} {}:{} - ".format(name[:30],ip, port)
        self.debug = debug
        self.debug_chaff = debug_chaff
        self.dprint("Launching Exploit")

    def get_flag(self):
        #open socket
        self.connect_to_server()
        #send exploit
        self.dprint("Getting Flag")
        self.flag = self.launch_exploit()
        #close socket if not already closed and return flag
        self.sock.close()
        return self.name, self.flag

    def send_chaff(self):
        #chaff can cause a ton of prints so turn off just chaff with debug_chaff
        old_debug = self.debug
        if not self.debug_chaff:
            self.debug = False
        self.connect_to_server()
        self.dprint("Sending Chaff")
        self.flag = self.launch_chaff()
        self.sock.close()
        #reset to old debug value
        self.debug = old_debug
        return self.flag

    #this is a debug print. Set debug to True to see
    #set debug to false to turn off
    def dprint(self, text):
        if self.debug:
            print(self.name + text.strip())

    #basic connect to client
    def connect_to_server(self):
        # Create a TCP/IP socket
        self.sock = socket(AF_INET, SOCK_STREAM)
        # Connect the socket to the port where the server is listening
        server_address = (self.ip, self.port)
        try:
            self.sock.connect(server_address)
            self.dprint('Connected to {} on port {}.'.format(self.ip, self.port))
        except OSError as e:
            self.dprint("ERROR establishing connection to {} on port {}".format(self.ip, self.port))
            sys.exit(1)

    #basic client_recv example
    def recv_until(self, endCharacter=None, decode_string='utf-8'):
        try:
            chunks = []
            chunk = b'starter'
            while chunk != b'' and chunk.decode('utf-8') != endCharacter:
                chunk = self.sock.recv(1)
                chunks.append(chunk)
            recv_msg = b''.join(chunks).decode(decode_string).strip()
            self.dprint("Received: " + recv_msg)
            return recv_msg
        except OSError as e:
            self.sock.close()
            self.dprint("ERROR receiving data from server: {}".format(e))
            sys.exit(1)

    def send(self, msg, socket):
        self.dprint(msg.strip())
        try:
            socket.send(msg.encode('utf-8'))
        except OSError as e:
            self.dprint("ERROR sending data: {}".format(e))
            sys.exit(1)

    def send_and_close(self, msg, socket):
        self.send(msg, socket)
        socket.close()



#example basic exploit test inside this same class file
class In_File_Test_Exploit(Exploit):
    def __init__(self, ip, port, name="", debug=False, debug_chaff=False):
        super().__init__(ip, port, name, debug, debug_chaff)

    def launch_exploit(self):
        # this is where you would write your own exploit code.
        # The end state is that you should return the flag
        #return "CTF{THISISMYOTHERFLAG}"

        #The below is functional test code if using server.py in test_server
        #just comment out the above return line
        recv_msg = self.recv_until('\n')
        flag = self.recv_until('\n').split(': ',1)[1].strip()
        return flag

    def launch_chaff(self):
        #This is where you would write a fake exploit that does not really
        #work, but looks real enough to cause them to waste time looking for
        #the real exploit.
        #pass

        #The below is functional test code if using server.py in test_server
        #just comment out the above pass line
        recv_msg = self.recv_until()
