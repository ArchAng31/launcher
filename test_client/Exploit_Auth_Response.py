#!/usr/bin/env python3

from Exploit import Exploit
from random import randint
import binascii
import hashlib
import os

class Auth_Response_Exploit(Exploit):
    def __init__(self, ip, port, name="", debug=False, debug_chaff=False):
        super().__init__(ip, port, name, debug, debug_chaff)

    def get_auth_string(self):
        if self.ip == '127.0.0.1':
            return "teamPass1001"
        elif self.ip == "chaff1":
            return "fakePassword1"
        elif self.ip == "chaff2":
            return binascii.b2a_hex(os.urandom(randint(6, 10))).decode('utf-8')

    def launch_exploit(self):
        recv_msg = self.recv_until('\n')
        auth_string = self.get_auth_string()
        one_time_pad = binascii.b2a_hex(os.urandom(20))[:len(auth_string)].decode('utf-8')
        xored_auth_string = ''.join([ chr(ord(a) ^ ord(b)) for (a,b) in zip(auth_string, one_time_pad) ])
        self.send(xored_auth_string+'\n', self.sock)
        recv_msg = self.recv_until('\n')
        self.send(one_time_pad+'\n', self.sock)
        final_msg = self.recv_until('\n')
        if "Congrats!" in final_msg:
            return final_msg.split(': ',1)[1].strip()


    def launch_chaff(self):
        #This is where you would write a fake exploit that does not really
        #work, but looks real enough to cause them to waste time looking for
        #the real exploit.
        random_int = randint(1, 2)
        if random_int == 1:
            self.ip = "chaff1"
        elif random_int == 2:
            self.ip = "chaff2"
        self.launch_exploit()
